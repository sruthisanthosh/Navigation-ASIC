\babel@toc {english}{}
\contentsline {chapter}{\numberline {}Abstract}{i}%
\contentsline {paragraph}{\textrm {\textmd {Systems designed for navigation require processing of real-time and conventional computing. This implies that the control hardware must be easily customizable, easy to debug, reliable and capable of handling real-time data, which may change depending on the application. These constraintsare typically met through two seperate solutions. A microcoontroller to handle control tasks and an FPGA to handle rela-time data. This is the optimal solution to the problem and is the the most widely accepted solution that currently exists. This project aims to integrate these two solutions onto a single Application Specific Integrated Circuit(ASIC) that meets all requirements. The Compute core, and programmable peripherals will be built up from scratch, along with essential core peripherals like UART and MIL-1553-STD. All other necessary protocols will be sourced from FPGA/ASIC proven open source, wishbone compatible peripherals. The aim of this project is create a roadmap for this special class of ASICs that have great value for the military as well as scientific application.}}}{i}%
\contentsline {chapter}{\numberline {}List of Figures}{iv}%
\contentsline {chapter}{\numberline {}List of Tables}{v}%
\contentsline {chapter}{\numberline {1}Introduction}{1}%
\contentsline {section}{\numberline {1.1}Background}{1}%
\contentsline {paragraph}{\textrm {\textmd {Many real time applications where control Systems are utilized benefit from having hardware that can handle real time data. In situations where large-scale production of Application Specific Integrated Circuits (ASICs) for each and every problem situation is not feasible most conventional design requirements are met using Field Programmable Gate Arrays (FPGAs). This approach yields the benefit of the same template hardware boards to be reconfigured as per the specific application, even on the fly and give considerable flexibility to the platform while also contributing heavily to the considerable cost of the overall design. Hence for applications like Navigation systems for satellites the benefits of both approaches can be combined to create an ASIC which includes a processing core, multiple configurable logic blocks, support for standard IO interface standards and protocols and ADC/DACs, all on the same silicon. This allows considerable benefits to help tailor custom hardware, specific to the needs where the system is to deployed while allowing for the reliability and cost-effectiveness of Large scale production of ASICs in house.}}}{1}%
\contentsline {paragraph}{\textrm {\textmd {RISC-V is an Open-Source, frozen, Instruction-set Architecture (ISA), initially developed at The University of California, Berkeley. The ISA is a becoming a vastly popular alternative to CISC architectures and proprietary popular RISC architectures like ARM. The applications the system will encouter warrants the use of RISCV32-IM, which is the integer operation base 32 bit variant of the RISC-V ISA, with the multiply/divide extension.The processing core should preferably be pipelined and have necessary hazard detection and mitigation schemes.}}}{1}%
\contentsline {paragraph}{\textrm {\textmd {The inclusion of FPGA Blocks on the die presents unique software and hardware challenges that require adapting known standard solutions to function in the unique environment the ASIC design creates.These include adapting bus standards for ease of communication with and programming of the FPGA. Establishing optimal routing for the given FPGA architecture and automating the process of synthesizing a design on the FPGA blocks using the processing core, handling and generation of multiple clock domains internally and ability for the SoC to drive output pins to different output voltage standards according to the application. This also brings about the need for an integrated onboard or external power management solution and multiple IO voltage domains. The project aims to create a unique ASIC that currently does not exist in the market and can find application in multiple domains. This document is orderedas follows. The Scope and Methodology adopted will be discussed in the following sections. Chapter 2 will discuss the Design overview and how the design process was formulated. Chapter 3 will elaborate on the overall Hardware and Software architecture and will illustrate an Top-Level view of the design. Chapter 4 will be where the design implementation details and detailed architecture will be discussed. All design elements will be elaborated here. Chapter 5 will elaborate how the designed ASIC is to be handled and how the phical chip can be brought onto a printed circuit Board and the necessary configuration and required support peripherals including power and pin mapping. Chapter 6 will conclude this document and shall discuss the overall process that was implemented and the actual results of the project and the road ahead.}}}{2}%
\contentsline {section}{\numberline {1.2}Scope}{2}%
\contentsline {paragraph}{\textrm {\textmd {The project will have four different goals to achieve based on the ideas presented in the preceeding section. Firstly, Design a usable RISC-V compute core that is flexible and light-weight. Secondly implement the Programmable FPGA cores and implement a programming scheme. and then implement the necessary peripherals. Thirdly, synthesise and test the SoC elements on an FPGA and lastly, tapeout and fabrication. All elements of the SoC will be written in chisel and exported to verilog. Verilator can be used to test the SoC at the verilog level and exported to the tapeout tools available at the IISU before final fabrication.}}}{2}%
\contentsline {chapter}{\numberline {2}Design Overview}{3}%
\contentsline {section}{\numberline {2.1}Introduction}{3}%
\contentsline {paragraph}{\textrm {\textmd { The RISC-V Instruction-set Architecture is highly pipelining friendly as well as being comparatively easier to implement in hardware than nore conventional RISC ISAs like MIPS. This enables the design of a fast, minimalistic, pipelined compute core that can easily work as a backbone for the additional components necessary to meet the application requirements. It follows that a flexible yet simple FPGA architecture needs to be identified keeping in mind both the ease of ease of implementation and ease of programming it by the core. The Navigation ASIC will encounter both Real-Time Data and Complex Decision making tasks. Hence the compute core and the FPGA elements have distict roles to play in the ASIC. The FPGA block can be programmed to have Logic that handles the real time data while the compute core can handle less time-constrained tasks. To take it one step further the FPGA can be programmed on the fly by the compute core, thus ensuring better flexibility for the ASIC as well as making it much more of a powerful solution, eventhouh the individual components are not by any stretch, new architectural elements.}}}{3}%
\contentsline {section}{\numberline {2.2}Constraints}{3}%
\contentsline {paragraph}{\textrm {\textmd {The proposed SoC should contain the following elements:}}}{3}%
\contentsline {section}{\numberline {2.3}Proposed process}{4}%
\contentsline {paragraph}{\textrm {\textmd {According to the resources available the preffered HDL for design has been determined to be a combination of verilog and chisel. The design will be tested on an FPGA and once validated the design can be prepared for layout and fabrication. The rest of the project will be implemented using the Cadence Software Toolchain. The design process can be summarized in the following steps:}}}{4}%
\contentsline {chapter}{\numberline {3}System Architecture}{5}%
\contentsline {section}{\numberline {3.1}Hardware Architecture}{5}%
\contentsline {paragraph}{\textrm {\textmd {The Architecture of the ASIC should provide the optimal balance of flexibility and reliability for the scenarios it is being designed for. This chapter is dedicated to the detailed architecture of the proposed ASIC}}}{5}%
\contentsline {subsection}{\numberline {3.1.1}Core Design}{5}%
\contentsline {paragraph}{\textrm {\textmd {ALU with add, multiply, subtract, division, and, or, not, xor, operation support. Five stage pipeline: Instruction Fetch(IF), Instruction Decode(ID), Execution/address calculation (EX), Memory fetch or write(MEM), Write Back(WB). Hazard Detection and avoidance: Forwarding, stalling and branch prediction( assume always dropped unless destination address precedes PC, 32 registers in register file (std),}}}{6}%
\contentsline {chapter}{\numberline {4}Detailed Design}{7}%
\contentsline {section}{\numberline {4.1}Compute Core}{7}%
\contentsline {paragraph}{\textrm {\textmd {The compute core is a five stage pipled RV-32IM processor as described in previous sections. This chapter illuastrates the functional blocks thatr comprise the core and their functionality.}}}{7}%
\contentsline {subsection}{\numberline {4.1.1}Instruction Fetch stage}{7}%
\contentsline {paragraph}{\textrm {\textmd {The Instruction Fetch(IF) stage is tasked with the reading and writing to Instruction memory, Program Counter updtaion and handling of pipeline stalls. Each of these tasks is handled in the following ways:}}}{7}%
\contentsline {paragraph}{\textrm {\textmd {A block schematic is illustrated in Fig.\ref {fig:ifstage}.The IF stage can be programmed for debugging using the first of two programming ports. The programming is done by halting the pipeline using the \textbf {io\_halt} line. The second read write port is mapped to a higher read address than the data memory. Refer memory map and archuitecture for more details.}}}{7}%
\contentsline {subsection}{\numberline {4.1.2}Execution Stage}{8}%
\contentsline {paragraph}{\textrm {\textmd {The Execution stage is, as the name implies, tasked with the execution of the instruction. The functional block diagram of the Stage is given in Fig.\ref {fig:exstage}. }}}{8}%
\contentsline {subsubsection}{ALU}{8}%
\contentsline {paragraph}{\textrm {\textmd {As per the requirements of the Compute core as described in the previous chapters, it is clear that an effective ALU must be simple, and support maximum hardware opeartions with minimal hardware utilization. Hence each possible opeartion the ALU can perform in hardware directly through a behavioural model is given a unique identifier signified by the bits of the \textbf {ALUctl} signal except the Most significant bit and secod-most significant bit. These bits explicitly describe the suboperation on the hardware to be performed. For example MUL, MULH, MULHSU and MULHU share the same \textbf {ALUctl[4:0]} value of 0101. The operations and their corresponding \textbf {ALUctl} values are summarized in Table~\ref {tab:alu}}}}{9}%
\contentsline {subsubsection}{ALUControl}{9}%
\contentsline {paragraph}{\textrm {\textmd {The \textbf {ALUctl} values specified in Table~\ref {tab:alu} can be used in conjunction with the RISCV instruction set user level encoding to generate a truth table for a peice of logic called the ALUControl. This Logic is tasked with decode the operation the ALU has to perform based on the Operation type specified by instruction using a signal generated by the Control Logic and additional Funct7 and Funct3 bits. this decoding is summarized in Tables ~\ref {tab:aluctl(a)} and ~\ref {tab:aluctl(b)}}}}{9}%
\contentsline {paragraph}{\textrm {\textmd {Using the information in Table~\ref {tab:aluctl} the values for all insputs for which each output bit of the \textbf {ALUctl} values can be extracted and the following output equations can be derived, assuming \textbf {ALUop} is represented by \textbf {a}, \textbf {Funct7} by \textbf {f} and \textbf {Funct3} by \textbf {b} as shown by Equations~\ref {eq:aluctl0} to ~\ref {eq:aluctl5}. They are heuristically reduced to a minimum size and implemented using a purely combinational circuit using gate based logic and it behaviourally.}}}{10}%
\contentsline {subsubsection}{Forwarding Unit}{11}%
\contentsline {paragraph}{\textrm {\textmd {The forwarding unit is tasked with ensuring that back-toback instructions that write and read to the same memmory location and/or the same register is handled smoothly in the pipeline. It functions by routing values from subsequent pipeline stages. Under these considerations three possible forwarding paths come up that the Forwarding Unit has to support. These are:}}}{11}%
\contentsline {subsubsection}{Branch Detection}{12}%
\contentsline {paragraph}{\textrm {\textmd {The branch detection Unit is tasked with Confirming that a Branch condition is valid and the branch can be taken. The Branch Predictors prediction is compared and the pipeline is stalled if the they disagree. The branch detction Unit is tasked with making sense of the condition for operations complementary to the Operations supported by the ALU. For example, the sub operation is used to identify wether two registers are equal in case of a BEQ(branch if Equal)instruction by just checking if the output of the ALU is zero, if not, the brach is dropped. The Logical Inverse of this operation is required for the BNE(Branch if Not Equal) instruction. This can be achieved by inverting the implications of the compare. If the ouput of the ALU is zero then the branch is dropped, else if the output is non-zero thenthe branch is taken. This can be extended to complementary Operational pairs like BLT and BGE (Branch if Less than and Branch of Greater than or Equal respectively) }}}{12}%
\contentsline {section}{\numberline {4.2}WISHBONE Bus}{12}%
\contentsline {paragraph}{\textrm {\textmd {The WISHBONE System-on-Chip (SOC) Interconnection is a method for connecting IP cores together to form integrated circuits. Open core SOC design methodology utilizes WISHBONE bus interface to foster design reuse by alleviating system-on-chip integration problems. With use of this standardize bus interface it is much easier to connect the cores, and therefore much easier to create a custom System-on-Chip.}}}{12}%
\contentsline {paragraph}{\textrm {\textmd {This way of SOC design improves the portability and reliability of the system, and results in faster time-to-market for the end user. The objective behind WISHBONE is to create a portable interface that supports both FPGA and ASIC that is independent of the semiconductor technology and WISHBONE interfaces should be independent of logic signaling levels.}}}{13}%
\contentsline {paragraph}{\textrm {\textmd {Another important reason is to create a flexible interconnection scheme that is independent of the type of IP core delivery (Hard, Soft IP) method. The next reasons are to have a standard interface that can be written using any hardware description language such as VHDL and VERILOG. It supports a variety of bus transfer cycle in which the data transaction is independent of the application specific functions of the IP cores. It also supports different types of interconnection architectures with theoretically infinite range of operating frequency. The final objective of WISHBONE bus is that it is absolutely free to use by developers without paying any fee for the cores available.}}}{13}%
\contentsline {subsection}{\numberline {4.2.1}WISHBONE Basics }{13}%
\contentsline {paragraph}{\textrm {\textmd {WISHBONE utilizes “Master” and “Slave” architectures which are connected to each other through an interface called “Intercon”. Master is an IP core that initiates the data transaction to the SLAVE IP core.Master starts transaction providing an address and control signal to Slave. Slave in turn responds to the data transaction with the Master with the specified address range.The Intercon is the medium consists of wires and logics which help in data transfer between Master and Slave. The Intercon also requires a “SYSCON” module which generates WISHBONE reset and clock signal for the proper functioning of the system. Figure:4.4 show the WISHBONE Intercon system which consists of Masters and Slaves and SYSCON modules. WISHBONE Intercon can be designed to operate over an infinite frequency range. This is called as variable time specification. The speed of the operation is only limited by the technology of the integrated circuits. The interconnection can be described using hardware description languages like VHDL and Verilog, and the system integrator can modify the interconnection according to the requirement of the design. Hence WISHBONE interface is different from traditional microcomputer buses such as PCI, VME bus and ISA bus. }}}{14}%
\contentsline {subsection}{\numberline {4.2.2}WISHBONE Features }{14}%
\contentsline {paragraph}{\textrm {\textmd {The WISHBONE interconnection makes System-on-Chip and design reuse easy by creating a standard data exchange protocol. Features of this technology include: }}}{14}%
\contentsline {paragraph}{\textrm {\textmd {The WISHBONE specification regulates the ordering of data. This is because data can be presented in two different ways. In the first way, the most significant byte of an operand is placed at the higher (bigger) address. In the second way, the most significant byte of an operand can be placed at the lower (smaller) address. These are called BIG ENDIAN and LITTLE ENDIAN data operands, respectively. WISHBONE supports both types. }}}{14}%
\contentsline {section}{\numberline {4.3}MIL STD 1553}{14}%
\contentsline {paragraph}{\textrm {\textmd {The Hardware elements of MIL-STD-1553 BUS consist of the data bus and terminals. The three terminals are:}}}{14}%
\contentsline {paragraph}{\textrm {\textmd {The Standard defines the data bus to be a single path among the bus controller and remote terminals.MIL-STD-1553B defines the data bus structure for interconnection of up to 31 remote terminal (RT) devices.}}}{15}%
\contentsline {paragraph}{\textrm {\textmd { A single controller device on the bus initiates the command/response communication with the remote devices. The remote and control devices are interconnected over two, separate buses.Normal operation involves only the primary bus with the secondary bus available as redundant backup in the event of primary bus damage or failure.The BC is the master device and operating as a bus controller. The BC initiates all theinformation transfers through the data bus. The standard specifies the informationtransfers between RTs to follow a command/response format.The BC sendscommands to the RTs to tell them what to do. The BC can be a separate subsystem or just a portion of a subsystem.The RT is the device interfaces the data bus to the sub-system and transfers data in and out of the subsystem.}}}{15}%
\contentsline {paragraph}{\textrm {\textmd {The RT can be an independent subsystem or it can be portion of the subsystem. The Standard allows for up to 31 RTs in a system.The MT is optional and works like a passive device which examines all data on the bus. It can record all data or selected data for off-line applications}}}{15}%
\contentsline {paragraph}{\textrm {\textmd {MIL-STD-1553 communication uses three word types:}}}{15}%
\contentsline {paragraph}{\textrm {\textmd {All these three words are of 20 bits in length. Three bits out of 20 bits are used for the word sync, 16 bits are used for information and the last one bit is for parity. The sync bit differentiates the data words from command and status words.In addition, mode messages are defined for managing the bus system and error recovery.}}}{15}%
\contentsline {subsection}{\numberline {4.3.1}Command Word}{16}%
\contentsline {paragraph}{\textrm {\textmd { The BC issues “Command Word (CW)” to RTs to perform specific functions. The CW is shown in the Figure \ref {fig:cmd}.The address field is 5 bit and the BC can address maximum 31 terminals.Command words are issued/transmitted only by the BC. BC directs any RT to transmit, receive or perform a specified action.}}}{16}%
\contentsline {subsection}{\numberline {4.3.2}Status Word}{16}%
\contentsline {paragraph}{\textrm {\textmd {A Remote terminal( RT)sends Status word in response to BCs command word. The status word is to convey that the transmission is OK or error.The status word is issued/transmitted only by a RT and provides general information on the state of the RT as shown in Figure \ref {fig:sts} }}}{16}%
\contentsline {subsection}{\numberline {4.3.3}Data Word}{16}%
\contentsline {paragraph}{\textrm {\textmd { The Data Word (DW) contains the actual information that is to be transferred within the message.Data words may be transmitted by either the BC or RT.Messages are from BC to RT transfers, RT to BC transfers, and RT to RT transfers.The first three-bits are “data sync” as shown in Figure \ref {fig:data}.}}}{16}%
\contentsline {chapter}{\numberline {5}Software Testing and Simulation}{19}%
\contentsline {chapter}{\numberline {6}FPGA Testing and Validation}{20}%
\contentsline {chapter}{\numberline {7}The Way Foreward}{21}%
\contentsline {chapter}{\numberline {8}Conclusion and Results}{22}%
