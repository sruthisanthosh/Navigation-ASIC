\relax 
\@nameuse{bbl@beforestart}
\babel@aux{english}{}
\@writefile{toc}{\contentsline {chapter}{ACKNOWLEDGEMENT}{i}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{ABSTRACT}{ii}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{LIST OF TABLES}{v}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{LIST OF FIGURES}{vi}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{\numberline {1}\large  INTRODUCTION}{1}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}\small  \MakeUppercase  {General Background}}{1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {Many real time applications where control Systems are utilized benefit from having hardware that can handle real time data. In situations where large-scale production of Application Specific Integrated Circuits (ASICs) for each and every problem situation is not feasible most conventional design requirements are met using Field Programmable Gate Arrays (FPGAs). This approach yields the benefit of the same template hardware boards to be reconfigured as per the specific application, even on the fly and give considerable flexibility to the platform while also contributing heavily to the considerable cost of the overall design. Hence for applications like Navigation systems for satellites the benefits of both approaches can be combined to create an ASIC which includes a processing core, multiple configurable logic blocks, support for standard IO interface standards and protocols and ADC/DACs, all on the same silicon. This allows considerable benefits to help tailor custom hardware, specific to the needs where the system is to deployed while allowing for the reliability and cost-effectiveness of Large scale production of ASICs in house.}}}{1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {RISC-V is an Open-Source, frozen, Instruction-set Architecture (ISA), initially developed at The University of California, Berkeley. The ISA is a becoming a vastly popular alternative to CISC architectures and proprietary popular RISC architectures like ARM. The applications the system will encouter warrants the use of RISCV32-IM, which is the integer operation base 32 bit variant of the RISC-V ISA, with the multiply/divide extension.The processing core should preferably be pipelined and have necessary hazard detection and mitigation schemes.}}}{2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The inclusion of FPGA Blocks on the die presents unique software and hardware challenges that require adapting known standard solutions to function in the unique environment the ASIC design creates.These include adapting bus standards for ease of communication with and programming of the FPGA. Establishing optimal routing for the given FPGA architecture and automating the process of synthesizing a design on the FPGA blocks using the processing core, handling and generation of multiple clock domains internally and ability for the SoC to drive output pins to different output voltage standards according to the application. This also brings about the need for an integrated onboard or external power management solution and multiple IO voltage domains. The project aims to create a unique ASIC that currently does not exist in the market and can find application in multiple domains. }}}{2}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.2}\small  \MakeUppercase  {Objective}}{2}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.3}\small  \MakeUppercase  {Scope}}{2}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.4}\small  \MakeUppercase  {Scheme of Project Work}}{3}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  { The RISC-V Instruction-set Architecture is highly pipelining friendly as well as being comparatively easier to implement in hardware than nore conventional RISC ISAs like MIPS. This enables the design of a fast, minimalistic, pipelined compute core that can easily work as a backbone for the additional components necessary to meet the application requirements. It follows that a flexible yet simple FPGA architecture needs to be identified keeping in mind both the ease of ease of implementation and ease of programming it by the core. The Navigation ASIC will encounter both Real-Time Data and Complex Decision making tasks. Hence the compute core and the FPGA elements have distict roles to play in the ASIC. The FPGA block can be programmed to have Logic that handles the real time data while the compute core can handle less time-constrained tasks. To take it one step further the FPGA can be programmed on the fly by the compute core, thus ensuring better flexibility for the ASIC as well as making it much more of a powerful solution, eventhouh the individual components are not by any stretch, new architectural elements.}}}{3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.5}Constraints}{3}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The proposed SoC should contain the following elements:}}}{3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.6}Proposed process}{4}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {According to the resources available the preffered HDL for design has been determined to be a combination of verilog and chisel. The design will be tested on an FPGA and once validated the design can be prepared for layout and fabrication. The rest of the project will be implemented using the Cadence Software Toolchain. The design process can be summarized in the following steps:}}}{4}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{\numberline {2}System Architecture}{5}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {2.1}Hardware Architecture}{5}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The Architecture of the ASIC should provide the optimal balance of flexibility and reliability for the scenarios it is being designed for. This chapter is dedicated to the detailed architecture of the proposed ASIC}}}{5}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1.1}Core Design}{5}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {ALU with add, multiply, subtract, division, and, or, not, xor, operation support. Five stage pipeline: Instruction Fetch(IF), Instruction Decode(ID), Execution/address calculation (EX), Memory fetch or write(MEM), Write Back(WB). Hazard Detection and avoidance: Forwarding, stalling and branch prediction( assume always dropped unless destination address precedes PC, 32 registers in register file (std),}}}{5}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {2.1}{\ignorespaces Navigation AISC Base Architecture Block Diagram}}{6}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{\numberline {3}Detailed Design}{7}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {3.1}Compute Core}{7}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The compute core is a five stage pipled RV-32IM processor as described in previous sections. This chapter illuastrates the functional blocks thatr comprise the core and their functionality.}}}{7}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1.1}Instruction Fetch stage}{7}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The Instruction Fetch(IF) stage is tasked with the reading and writing to Instruction memory, Program Counter updtaion and handling of pipeline stalls. Each of these tasks is handled in the following ways:}}}{7}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.1}{\ignorespaces Instruction Stage Block Schematic}}{8}\protected@file@percent }
\newlabel{fig:ifstage}{{3.1}{8}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {A block schematic is illustrated in Fig.\ref  {fig:ifstage}.The IF stage can be programmed for debugging using the first of two programming ports. The programming is done by halting the pipeline using the \textbf  {io\_halt} line. The second read write port is mapped to a higher read address than the data memory. Refer memory map and archuitecture for more details.}}}{8}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1.2}Execution Stage}{8}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The Execution stage is, as the name implies, tasked with the execution of the instruction. The functional block diagram of the Stage is given in Fig.\ref  {fig:exstage}. }}}{8}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{ALU}{8}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.2}{\ignorespaces Execution Stage Block Schematic}}{9}\protected@file@percent }
\newlabel{fig:exstage}{{3.2}{9}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {As per the requirements of the Compute core as described in the previous chapters, it is clear that an effective ALU must be simple, and support maximum hardware opeartions with minimal hardware utilization. Hence each possible opeartion the ALU can perform in hardware directly through a behavioural model is given a unique identifier signified by the bits of the \textbf  {ALUctl} signal except the Most significant bit and secod-most significant bit. These bits explicitly describe the suboperation on the hardware to be performed. For example MUL, MULH, MULHSU and MULHU share the same \textbf  {ALUctl[4:0]} value of 0101. The operations and their corresponding \textbf  {ALUctl} values are summarized in Table~\ref  {tab:alu}}}}{9}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{ALUControl}{9}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The \textbf  {ALUctl} values specified in Table~\ref  {tab:alu} can be used in conjunction with the RISCV instruction set user level encoding to generate a truth table for a peice of logic called the ALUControl. This Logic is tasked with decode the operation the ALU has to perform based on the Operation type specified by instruction using a signal generated by the Control Logic and additional Funct7 and Funct3 bits. this decoding is summarized in Tables ~\ref  {tab:aluctl(a)} and ~\ref  {tab:aluctl(b)}}}}{9}\protected@file@percent }
\@writefile{lot}{\contentsline {table}{\numberline {3.1}{\ignorespaces ALU Operations with their corresponfing ALUctl line values}}{10}\protected@file@percent }
\newlabel{tab:alu}{{3.1}{10}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {Using the information in Table~\ref  {tab:aluctl} the values for all insputs for which each output bit of the \textbf  {ALUctl} values can be extracted and the following output equations can be derived, assuming \textbf  {ALUop} is represented by \textbf  {a}, \textbf  {Funct7} by \textbf  {f} and \textbf  {Funct3} by \textbf  {b} as shown by Equations~\ref  {eq:aluctl0} to ~\ref  {eq:aluctl5}. They are heuristically reduced to a minimum size and implemented using a purely combinational circuit using gate based logic and it behaviourally.}}}{10}\protected@file@percent }
\newlabel{eq:aluctl0}{{3.1}{10}}
\newlabel{eq:aluctl1}{{3.2}{11}}
\newlabel{eq:aluctl2}{{3.3}{11}}
\newlabel{eq:aluctl3}{{3.4}{11}}
\newlabel{eq:aluctl4}{{3.5}{11}}
\newlabel{eq:aluctl5}{{3.6}{11}}
\@writefile{toc}{\contentsline {subsubsection}{Forwarding Unit}{11}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The forwarding unit is tasked with ensuring that back-toback instructions that write and read to the same memmory location and/or the same register is handled smoothly in the pipeline. It functions by routing values from subsequent pipeline stages. Under these considerations three possible forwarding paths come up that the Forwarding Unit has to support. These are:}}}{11}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{Branch Detection}{12}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The branch detection Unit is tasked with Confirming that a Branch condition is valid and the branch can be taken. The Branch Predictors prediction is compared and the pipeline is stalled if the they disagree. The branch detction Unit is tasked with making sense of the condition for operations complementary to the Operations supported by the ALU. For example, the sub operation is used to identify wether two registers are equal in case of a BEQ(branch if Equal)instruction by just checking if the output of the ALU is zero, if not, the brach is dropped. The Logical Inverse of this operation is required for the BNE(Branch if Not Equal) instruction. This can be achieved by inverting the implications of the compare. If the ouput of the ALU is zero then the branch is dropped, else if the output is non-zero thenthe branch is taken. This can be extended to complementary Operational pairs like BLT and BGE (Branch if Less than and Branch of Greater than or Equal respectively) }}}{12}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3.2}WISHBONE Bus}{12}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The WISHBONE System-on-Chip (SOC) Interconnection is a method for connecting IP cores together to form integrated circuits. Open core SOC design methodology utilizes WISHBONE bus interface to foster design reuse by alleviating system-on-chip integration problems. With use of this standardize bus interface it is much easier to connect the cores, and therefore much easier to create a custom System-on-Chip.}}}{12}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {This way of SOC design improves the portability and reliability of the system, and results in faster time-to-market for the end user. The objective behind WISHBONE is to create a portable interface that supports both FPGA and ASIC that is independent of the semiconductor technology and WISHBONE interfaces should be independent of logic signaling levels.}}}{12}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.3}{\ignorespaces Wishbone Bus Interface}}{13}\protected@file@percent }
\newlabel{fig:interface}{{3.3}{13}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {Another important reason is to create a flexible interconnection scheme that is independent of the type of IP core delivery (Hard, Soft IP) method. The next reasons are to have a standard interface that can be written using any hardware description language such as VHDL and VERILOG. It supports a variety of bus transfer cycle in which the data transaction is independent of the application specific functions of the IP cores. It also supports different types of interconnection architectures with theoretically infinite range of operating frequency. The final objective of WISHBONE bus is that it is absolutely free to use by developers without paying any fee for the cores available.}}}{13}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.1}WISHBONE Basics }{13}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.4}{\ignorespaces Interconnection System}}{14}\protected@file@percent }
\newlabel{fig:wb}{{3.4}{14}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {WISHBONE utilizes “Master” and “Slave” architectures which are connected to each other through an interface called “Intercon”. Master is an IP core that initiates the data transaction to the SLAVE IP core.Master starts transaction providing an address and control signal to Slave. Slave in turn responds to the data transaction with the Master with the specified address range.The Intercon is the medium consists of wires and logics which help in data transfer between Master and Slave. The Intercon also requires a “SYSCON” module which generates WISHBONE reset and clock signal for the proper functioning of the system. Figure:4.4 show the WISHBONE Intercon system which consists of Masters and Slaves and SYSCON modules. WISHBONE Intercon can be designed to operate over an infinite frequency range. This is called as variable time specification. The speed of the operation is only limited by the technology of the integrated circuits. The interconnection can be described using hardware description languages like VHDL and Verilog, and the system integrator can modify the interconnection according to the requirement of the design. Hence WISHBONE interface is different from traditional microcomputer buses such as PCI, VME bus and ISA bus. }}}{14}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.2}WISHBONE Features }{14}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The WISHBONE interconnection makes System-on-Chip and design reuse easy by creating a standard data exchange protocol. Features of this technology include: }}}{14}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The WISHBONE specification regulates the ordering of data. This is because data can be presented in two different ways. In the first way, the most significant byte of an operand is placed at the higher (bigger) address. In the second way, the most significant byte of an operand can be placed at the lower (smaller) address. These are called BIG ENDIAN and LITTLE ENDIAN data operands, respectively. WISHBONE supports both types. }}}{15}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3.3}MIL STD 1553}{15}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.5}{\ignorespaces MIL STD 1553}}{15}\protected@file@percent }
\newlabel{fig:1553}{{3.5}{15}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The Hardware elements of MIL-STD-1553 BUS consist of the data bus and terminals. The three terminals are:}}}{15}\protected@file@percent }
\@writefile{toc}{\contentsline {subparagraph}{Remote Terminal}{16}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.6}{\ignorespaces Terminal Definition}}{16}\protected@file@percent }
\newlabel{fig:rt}{{3.6}{16}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {A remote terminal typically consists of a transceiver, an encoder/decoder, a protocol controller, a buffer or memory, and a subsystem interface. In a modern black box containing a computer or processor, the subsystem interface may consist of the buffers and logic necessary to interface to the computer's address, data, and control buses. For dual redundant systems, the most prevalent in today's applications, two transceivers and two encod- ers/decoders would be required.It should be pointed out that if the remote terminal shares common memory (verses private), then that portion of the memory that the remote terminal can address should be considered part of the remote terminal.The remote terminal consists of all the electronics necessary to transfer data between the data bus and the user or originator of the data being transferred.}}}{17}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {But a remote terminal must be more than just a data formatter. It must be capable of receiving and decoding commands from the bus controller and responding accordingly. It must also be capable of buffering a message worth of data, detecting transmission errors and performing validation tests upon the data, and reporting the status of the message transfer. A remote terminal must follow the protocol defined by the standard. It can only respond to commands received from the bus controller. When it receives a valid command, it must respond within a very small, closely defined amount of time. If a message doesn’t meet the validity requirements defined, then the remote terminal must invalidate the message and discard the data. In addition to reporting status to the bus controller, most remote terminals today are capable of providing some level of status information to the subsystem.}}}{17}\protected@file@percent }
\@writefile{toc}{\contentsline {subparagraph}{Bus Controller}{17}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The bus controller is responsible for directing the flow of data on the data bus. While several terminals may be capable of performing as the bus controller, only one bus controller may be active at a time. The bus controller is the only one allowed to issue commands onto the data bus. The commands may be for the transfer of data or the control and manage- ment of the bus (mode commands). Typically, the bus controller is a function that is contained within some other computer, such as a mission computer, a display processor, or a fire control computer. The complexity of the electronics associated with the bus controller is a function of the subsystem interface, the amount of error management and processing to be performed, and the architecture of the bus controller.}}}{17}\protected@file@percent }
\@writefile{toc}{\contentsline {subparagraph}{Bus Monitor}{17}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {A bus monitor is a terminal that listens (monitors) to the exchange of information on the data bus. The standard strictly defines how bus monitors may be used, stating that the information obtained by a bus monitor be used “for off-line applications (e.g., flight test recording, maintenance recording or mission analysis) or to provide the back-up bus controller sufficient information to take over as the bus controller.” A monitor may collect all the data from the bus or may collect selected data. The reason for restricting its use is that while a monitor may collect data, it deviates from the command-response protocol of the standard, in that a monitor is a passive device that doesn’t transmit a status word and therefore cannot report on the status of the information transferred. Bus monitors fall into two categories:}}}{18}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {In collecting data, a monitor must perform the same message validation functions as the remote terminal and if an error is detected, inform the subsystem of the error (the subsystem may still record the data, but the error should be noted). For monitors, which function as recorders for testing, the subsystem is typically a recording device such as a magnetic tape or disk, or a telemetry transmitter. For monitors, which function as back-up bus controllers, the subsystem is the computer. Today it is common for bus monitors to contain a remote terminal. When the monitor receives a command addressed to its terminal address, it responds as a remote terminal. For all other commands, it functions as a monitor. The remote terminal portion can be used to provide feedback to the bus controller, which monitors status and the amount of memory or time (i.e. recording tape) left. The remote terminal portion also can be used to reprogram a selective monitor as to what messages to capture.}}}{18}\protected@file@percent }
\@writefile{toc}{\contentsline {subparagraph}{Operation}{18}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The Standard defines the data bus to be a single path among the bus controller and remote terminals.MIL-STD-1553B defines the data bus structure for interconnection of up to 31 remote terminal (RT) devices.}}}{18}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  { A single controller device on the bus initiates the command/response communication with the remote devices. The remote and control devices are interconnected over two, separate buses.Normal operation involves only the primary bus with the secondary bus available as redundant backup in the event of primary bus damage or failure.The BC is the master device and operating as a bus controller. The BC initiates all theinformation transfers through the data bus. The standard specifies the informationtransfers between RTs to follow a command/response format.The BC sendscommands to the RTs to tell them what to do. The BC can be a separate subsystem or just a portion of a subsystem.The RT is the device interfaces the data bus to the sub-system and transfers data in and out of the subsystem.}}}{19}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {The RT can be an independent subsystem or it can be portion of the subsystem. The Standard allows for up to 31 RTs in a system.The MT is optional and works like a passive device which examines all data on the bus. It can record all data or selected data for off-line applications}}}{19}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {MIL-STD-1553 communication uses three word types:}}{19}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {All these three words are of 20 bits in length. Three bits out of 20 bits are used for the word sync, 16 bits are used for information and the last one bit is for parity. The sync bit differentiates the data words from command and status words.In addition, mode messages are defined for managing the bus system and error recovery.}}}{19}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3.1}Command Word}{19}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.7}{\ignorespaces Word Formats}}{20}\protected@file@percent }
\newlabel{fig:word}{{3.7}{20}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  { The BC issues “Command Word (CW)” to RTs to perform specific functions. The CW is shown in the Figure \ref  {fig:cmd}.The address field is 5 bit and the BC can address maximum 31 terminals.Command words are issued/transmitted only by the BC. BC directs any RT to transmit, receive or perform a specified action.}}}{20}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3.2}Status Word}{20}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  {A Remote terminal( RT)sends Status word in response to BCs command word. The status word is to convey that the transmission is OK or error.The status word is issued/transmitted only by a RT and provides general information on the state of the RT as shown in Figure \ref  {fig:sts} }}}{20}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3.3}Data Word}{20}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.8}{\ignorespaces Command Word}}{21}\protected@file@percent }
\newlabel{fig:cmd}{{3.8}{21}}
\@writefile{toc}{\contentsline {paragraph}{\textrm  {\textmd  { The Data Word (DW) contains the actual information that is to be transferred within the message.Data words may be transmitted by either the BC or RT.Messages are from BC to RT transfers, RT to BC transfers, and RT to RT transfers.The first three-bits are “data sync” as shown in Figure \ref  {fig:data}.}}}{21}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {3.9}{\ignorespaces Status Word}}{22}\protected@file@percent }
\newlabel{fig:sts}{{3.9}{22}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.10}{\ignorespaces Data Word}}{22}\protected@file@percent }
\newlabel{fig:data}{{3.10}{22}}
\@writefile{lot}{\contentsline {table}{\numberline {3.2}{\ignorespaces Intruction decode sequence(pto)}}{23}\protected@file@percent }
\newlabel{tab:aluctl(a)}{{3.2}{23}}
\@writefile{lot}{\contentsline {table}{\numberline {3.3}{\ignorespaces Intruction decode sequence(contd..)}}{24}\protected@file@percent }
\newlabel{tab:aluctl(b)}{{3.3}{24}}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}\large  \MakeUppercase  {Litreature Survey}}{25}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {chapter}{\numberline {5}\large  \MakeUppercase  {Theoretical Analysis and Modelling}}{26}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {chapter}{\numberline {6}\large  \MakeUppercase  {Computational Simulation \& verification}}{27}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {chapter}{\numberline {7}\large  \MakeUppercase  {Experimental Testing \& Validation}}{28}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\ttl@finishall
